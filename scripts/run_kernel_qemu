#!/bin/bash

# qemu-system-aarch64 \
#     -M "${board_model}" -dtb "${fdt_blob}" -serial null -serial mon:stdio \
#     -display none -m 1024 \
#     -netdev user,id=net0,hostfwd=udp::6666-:6666 \
#     -initrd "${initramfs}" -kernel "${kernel_image}" -append "console=ttyPS0,115200"

check_boot_files () {
    for file in "$@"; do
        if [[ ! -f "${file}" ]]; then
            return 1
        fi
    done
    return 0
}

#qemu_emulator=/opt/bin/qemu-system-aarch64
qemu_emulator=qemu-system-aarch64
machine=xilinx-zynq-a9

proj_dir="$(realpath -e ./)"
rootfs_dir="${proj_dir}/rootfs"
shared_dir="${proj_dir}/shared"

dtb_path="${rootfs_dir}/boot/zynq-zc702.dtb"
kernel_path="${rootfs_dir}/boot/zImage"
initrd_path="${proj_dir}/initramfs.cpio.gz"

# Kernel command line arguments - don't disable fabric clocks that don't have a
# drivers
# kernel_cmd_line="console=ttyPS0,115200 clk_ignore_unused"
kernel_cmd_line="quiet"

# Building up the argument to the -fsdev option that gets
fsdev_cmd=""
fsdev_cmd+="local"                      # fsdriver
fsdev_cmd+=",id=fsdev0"                 # Identifier for the device
fsdev_cmd+=",path=${shared_dir}"        # Export parth in host
fsdev_cmd+=",security_model=none"       # Full bidirectional access, no failures
fsdev_cmd+=",writeout=immediate"        # Only supported value
# fsdev_cmd+=",readonly=on"             # Default is read-write

virtio_9p_device=""
virtio_9p_device+="virtio-9p-device"    # Driver variant, in this case PCI
virtio_9p_device+=",fsdev=fsdev0"       # Same ID used with -fsdev option
virtio_9p_device+=",mount_tag=shared"   # Tag name used by the guest to mount it
virtio_9p_device+=",id=fs0"

virtio_mmio=""
virtio_mmio+="virtio-mmio"
virtio_mmio+=",device=fs0"
virtio_mmio+=",addr=0x1000"

# Do some basic checks of the environment and boot components before we
# invoke the emulator
command -v "${qemu_emulator}" >/dev/null 2>&1 || \
    { printf '%s\n' "Error: QEMU emulator for ARM not installed" >&2; exit 1; }

check_boot_files "${dtb_path}" "${kernel_path}" "${initrd_path}" || \
    { printf '%s\n' "Error: Missing boot files" >&2; exit 1; }

# Check that the shared location exists too
mkdir -pv "${shared_dir}"
if [[ ! -w "${shared_dir}" ]]; then
    printf '%s\n' "Error: Shared directory does not exist or is not writable by current user" >&2
    exit 1
fi
# Invoke the emulator for the Zynq board with the appropriate boot files. 

# From the QEMU system emulation documentation, the general form of calling the
# emulator is
#
# $ qemu-system-x86_64 [machine opts] \
#                 [cpu opts] \
#                 [accelerator opts] \
#                 [device opts] \
#                 [backend opts] \
#                 [interface opts] \
#                 [boot opts]
#
# printf '%s\n' "-fsdev ${fsdev_cmd}"
# printf '%s\n' "-device ${virtio_9p_device}"
# printf '%s\n' "-device ${virtio_mmio}"

"${qemu_emulator}" \
    -machine type="${machine}" \
    -accel tcg \
    -dtb "${dtb_path}" \
    -serial null \
    -serial stdio \
    -monitor telnet:127.0.0.1:55555,server,nowait \
    -display none \
    -initrd "${initrd_path}" \
    -kernel "${kernel_path}" \
    -append "${kernel_cmd_line}" \
    -net nic -net user,hostfwd=udp::6666-:6666 \
    -m 2048M

    # -net user,hostfwd=udp::6666-:6666 \
    # -netdev user,id=net0,hostfwd=udp::6666-:6666 \
    # -fsdev "${fsdev_cmd}" \
    # -device "${virtio_mmio}" \
    # -device "${virtio_9p_device}" \
